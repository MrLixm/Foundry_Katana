<katana release="4.5v1" version="4.5.1.000008">
  <node name="__SAVE_exportedNodes" type="Group">
    <node baseType="Group" eyepointx="10.6631" eyepointy="-3006.67" eyepointz="0.0" name="LightViewerAnnotate" ns_basicDisplay="1.0" ns_errorGlow="0.0" ns_fromContext="legacy" ns_iconName="" ns_viewState="2" selected="true" type="Group" viewscalex="1.0" viewscaley="1.0" viewscalez="1.0" x="32.0" y="-208.0">
      <port name="i0" source="GafferThree.out" type="in"/>
      <port name="o0" type="out"/>
      <group_parameter name="LightViewerAnnotate">
        <group_parameter hints="{&apos;hideTitle&apos;: &apos;True&apos;}" name="user">
          <string_parameter hints="{&apos;help&apos;: &apos;&lt;p&gt;this is build using tokens(ex: &amp;lt;token&amp;gt;)&lt;/p&gt;\n&lt;p&gt;\ntokens available depends of the script configuration. &lt;br&gt; Available tokens for Arnold are:\n&lt;/p&gt;\n&lt;i&gt;\naov, name, color, samples, exposure, intensity\n&lt;/i&gt;&apos;}" name="annotation" value="&lt;name&gt;_&lt;exposure&gt;"/>
          <string_parameter hints="{&apos;widget&apos;: &apos;cel&apos;, &apos;help&apos;: &apos;&lt;p&gt;Make sure the locations matched by CEL are &lt;b&gt;only&lt;/b&gt; lights.&lt;/p&gt;&apos;}" name="CEL" value="((/root/world/lgt//*{@type == &quot;light&quot;}))"/>
          <group_parameter name="color">
            <number_parameter hints="{&apos;widget&apos;: &apos;boolean&apos;}" name="annotations_colored" value="0"/>
            <number_parameter hints="{&apos;widget&apos;: &apos;boolean&apos;}" name="lights_colored" value="0"/>
            <number_parameter hints="{&apos;slidercenter&apos;: &apos;1.0&apos;, &apos;max&apos;: &apos;4.0&apos;, &apos;slidermax&apos;: &apos;4.0&apos;, &apos;slider&apos;: &apos;True&apos;}" name="color_gamma" value="1"/>
          </group_parameter>
          <group_parameter name="about">
            <string_parameter name="author_" value="Liam Collod"/>
            <string_parameter name="info_" value="Annotate (&amp; color) lights in the viewer using their attributes.&#0010;"/>
            <number_parameter name="version_" value="1"/>
          </group_parameter>
        </group_parameter>
      </group_parameter>
      <node baseType="OpScript" name="OpS_lva_0001" ns_errorGlow="0.0" ns_viewState="2" type="OpScript" x="2e-06" y="-3008">
        <port name="i0" source="Dot48.output" type="in"/>
        <port name="out" type="out"/>
        <group_parameter name="OpS_lva_0001">
          <string_parameter expression="=^/user.CEL" name="CEL"/>
          <string_parameter name="location" value="/root/world/location"/>
          <group_parameter name="script">
            <string_parameter name="lua" value="--[[&#0010;version=10&#0010;&#0010;OpScript for Foundry&apos;s Katana software&#0010;This script is compatible with Arnold but can be modified to others.&#0010;&#0010;Annotate (&amp; color) lights in the viewer using their attributes.&#0010;&#0010;Author: Liam Collod&#0010;Last Modified: 05/03/2022&#0010;&#0010;[OpScript setup]&#0010;parameters:&#0010;    location:  /root/world/lgt//*{@type==&quot;light&quot;}&#0010;    applyWhere: at locations matching CEL&#0010;user(type)(default_value):&#0010;  user.annotation_color_gamma(float)(2): gamma controler for the color if lights and annotations&#0010;  user.annotation_colored(bool)(true): true to colro the annotation in the viewer&#0010;  user.lights_colored(bool)(true): true to color the light in the viewer&#0010;  user.annotation_template(str)(&quot;&lt;name&gt;&quot;): Use tokens to build the annotation for each light.&#0010;     tokens are defined in Light.attributes and are surrounded with &lt;&gt;&#0010;]]&#0010;&#0010;&#0010;--[[ __________________________________________________________________________&#0010;  LUA UTILITIES&#0010;]]&#0010;&#0010;local split&#0010;local round&#0010;local table2string&#0010;local stringify&#0010;&#0010;split = function(str, sep)&#0010;  --[[&#0010;  Source: https://stackoverflow.com/a/25449599/13806195&#0010;  ]]&#0010;  local result = {}&#0010;  local regex = (&quot;([^%s]+)&quot;):format(sep)&#0010;  for each in str:gmatch(regex) do&#0010;     table.insert(result, each)&#0010;  end&#0010;  return result&#0010;end&#0010;&#0010;&#0010;round = function(num, numDecimalPlaces)&#0010;  -- Source: http://lua-users.org/wiki/SimpleRound&#0010;  -- Returns: number&#0010;  return tonumber(string.format(&quot;%.&quot; .. (numDecimalPlaces or 0) .. &quot;f&quot;, num))&#0010;end&#0010;&#0010;&#0010;table2string = function(tablevalue)&#0010;    --[[&#0010;  Convert a table to a one line string.&#0010;  If the key is a number, only the value is kept.&#0010;  If the key is something else, it is formatted to &quot;tostring(key)=tostring(value),&quot;&#0010;&#0010;  Parameters:&#0010;    tablevalue(table): table to convert to string&#0010;&#0010;  Returns:&#0010;    str:&#0010;  ]]&#0010;&#0010;  local outtable = {&quot;{&quot;}&#0010;  local ctable = {} -- to avoid string concatenation in loop&#0010;&#0010;  for k, v in pairs(tablevalue) do&#0010;    -- to avoid string concatenation in loop&#0010;    if (type(k) == &quot;number&quot;) then&#0010;      table.insert(outtable, stringify(v)..&quot;, &quot;)&#0010;    else&#0010;      ctable[1] = stringify(k)&#0010;      ctable[2] = &quot;=&quot;&#0010;      ctable[3] = stringify(v)&#0010;      ctable[4] = &quot;, &quot;&#0010;      table.insert(outtable,tostring(table.concat(ctable)))&#0010;    end&#0010;  end&#0010;&#0010;  table.insert(outtable, &quot;}&quot;)&#0010;&#0010;  return table.concat(outtable)&#0010;&#0010;end&#0010;&#0010;&#0010;stringify = function(source)&#0010;    --[[ Convert the source to a readable string , based on it&apos;s type.&#0010;    All numbers are rounded to 3 decimals.&#0010;    ]]&#0010;    local number_round = 3  -- number of decimals to keep.&#0010;&#0010;    if (type(source) == &quot;table&quot;) then&#0010;      if #source == 1 then&#0010;        return source[1]&#0010;      end&#0010;      source = table2string(source)&#0010;&#0010;    elseif (type(source) == &quot;number&quot;) then&#0010;      source = tostring(round(source, number_round))&#0010;&#0010;    else&#0010;      source = tostring(source)&#0010;&#0010;    end&#0010;&#0010;  return source&#0010;&#0010;end&#0010;&#0010;&#0010;&#0010;--[[ __________________________________________________________________________&#0010;  API UTILITIES&#0010;]]&#0010;&#0010;&#0010;local function color_gamma(color, gamma)&#0010;  --[[&#0010;  Change the gamma of the given color value (float3)&#0010;&#0010;  Args:&#0010;    color(table): table of float&#0010;    gamma(float): gamma value to apply&#0010;  ]]&#0010;  local out = color&#0010;  for index, color_channel in pairs(color) do&#0010;    out[index] = color_channel ^ gamma&#0010;  end&#0010;  return out&#0010;&#0010;end&#0010;&#0010;local function get_user_attr(name, default_value)&#0010;    --[[&#0010;    Return an OpScipt user attribute.&#0010;    If not found return the default_value&#0010;&#0010;    Args:&#0010;        name(str): attribute location (don&apos;t need the &lt;user.&gt;&#0010;        default_value(any): value to return if user attr not found&#0010;    Returns:&#0010;        type depends of input&#0010;    ]]&#0010;    local argvalue = Interface.GetOpArg(&quot;user.&quot;..name)&#0010;    if argvalue then&#0010;        return argvalue:getValue()&#0010;    else&#0010;      return default_value&#0010;    end&#0010;&#0010;end&#0010;&#0010;&#0010;local Light = {}&#0010;function Light:new(location)&#0010;  --[[&#0010;  This is the classes that will allow to query a light attributes.&#0010;  The system was designed to be flexible(render-agnostic) but this example&#0010;  if for Arnold.&#0010;&#0010;  Customization is performed through self.attributes which is a table:&#0010;    - each table key is an abitrary string representing the attribute name&#0010;      - its value is a table of 2 fixed items:&#0010;        - key:func = function to execute that will return the value querried.&#0010;        - key:params = table of arguments to pass to the above function (with unpack())&#0010;&#0010;  You can of course create any method here that can be then used in self.attributes.&#0010;&#0010;  ]]&#0010;&#0010;  local attrs = {&#0010;    location = location,&#0010;    attributes = {}&#0010;  }&#0010;&#0010;  function attrs:get(attr_name)&#0010;    --[[&#0010;    Return the light attribute value for the given attribute name&#0010;&#0010;    Returns:&#0010;      type depends of what&apos;s queried, can be nil&#0010;    ]]&#0010;    local attr = self.attributes[attr_name]&#0010;    return attr.func(self, unpack(attr.params))&#0010;  end&#0010;&#0010;  function attrs:get_attr(attr_name, default_value)&#0010;  --[[&#0010;    Args:&#0010;        attr_name(str): name of the attribute to get&#0010;        default_value(any): value to return if attr not found&#0010;    Returns:&#0010;        type depends of input&#0010;    ]]&#0010;    local attr = Interface.GetAttr(attr_name)&#0010;    if attr then&#0010;      return attr:getNearestSample(0)&#0010;    else&#0010;      return default_value&#0010;    end&#0010;  end&#0010;&#0010;  function attrs:get_name()&#0010;    --[[&#0010;    Returns:&#0010;      str: name of the light based on its scene graph location.&#0010;    ]]&#0010;    local name = split(self.location, &quot;/&quot;)&#0010;    return name[#name]  -- return the last element of the list&#0010;  end&#0010;&#0010;  -- post process the attrs for the one requiring the methods to be created.&#0010;&#0010;  attrs.attributes = {&#0010;      aov = {&#0010;        func = attrs.get_attr,&#0010;        params = {&quot;material.arnoldLightParams.aov&quot;, &quot;default&quot;},&#0010;      },&#0010;      name = {&#0010;        func = attrs.get_name,&#0010;        params = {},&#0010;      },&#0010;      color = {&#0010;        func = attrs.get_attr,&#0010;        params = {&quot;material.arnoldLightParams.color&quot;, {1,1,1}},&#0010;      },&#0010;      samples = {&#0010;        func = attrs.get_attr,&#0010;        params = {&quot;material.arnoldLightParams.samples&quot;, 1},&#0010;      },&#0010;      exposure = {&#0010;        func = attrs.get_attr,&#0010;        params = {&quot;material.arnoldLightParams.exposure&quot;, 0.0},&#0010;      },&#0010;      intensity = {&#0010;        func = attrs.get_attr,&#0010;        params = {&quot;material.arnoldLightParams.intensity&quot;, 1.0},&#0010;      },&#0010;  }&#0010;&#0010;  return attrs&#0010;&#0010;end&#0010;&#0010;local function process_annotation(annotation, light)&#0010;  --[[&#0010;  Args:&#0010;    annotation(str): annotation template submitted by the user (with tokens)&#0010;    light(table): currently processed light object.&#0010;  Returns:&#0010;    str: annotation with the tokens replaced&#0010;  ]]&#0010;  for attr_name, attr_getter in pairs(light.attributes) do&#0010;    local token = &quot;&lt;&quot;..attr_name..&quot;&gt;&quot;&#0010;    local value = stringify(light:get(attr_name))&#0010;    annotation = string.gsub(annotation, token, value)&#0010;  end&#0010;&#0010;  return annotation&#0010;&#0010;end&#0010;&#0010;&#0010;local function run()&#0010;&#0010;  local annotation_template = get_user_attr(&quot;annotation_template&quot;, &quot;&lt;name&gt;&quot;)&#0010;  local annotation_color_gamma = get_user_attr(&quot;annotation_color_gamma&quot;, 1)&#0010;  local annotation_colored = get_user_attr(&quot;annotation_colored&quot;, 1)&#0010;  local lights_colored = get_user_attr(&quot;lights_colored&quot;, 1)&#0010;&#0010;&#0010;  local light = Light:new(Interface.GetInputLocationPath())&#0010;  local annotation = process_annotation(annotation_template, light)&#0010;  local color = light:get(&quot;color&quot;) -- table of float or nil&#0010;  if color then&#0010;     color = color_gamma(color, annotation_color_gamma)&#0010;  end&#0010;&#0010;  if annotation_colored==1 then&#0010;    Interface.SetAttr(&#0010;        &quot;viewer.default.annotation.color&quot;,&#0010;        FloatAttribute(color or {0.1, 0.1, 0.1})&#0010;    )&#0010;  end&#0010;&#0010;  if lights_colored==1 then&#0010;    Interface.SetAttr(&#0010;        &quot;viewer.default.drawOptions.color&quot;,&#0010;        FloatAttribute(color or {0.1, 1.0, 1.0})&#0010;    )&#0010;  end&#0010;&#0010;  Interface.SetAttr(&quot;viewer.default.annotation.text&quot;, StringAttribute(annotation))&#0010;&#0010;  --print(&quot;[LightViewerAnnotate][run] Finished. Annotation set to &lt;&quot;..annotation..&quot;&gt;&quot;)&#0010;&#0010;end&#0010;&#0010;-- execute&#0010;run()"/>
          </group_parameter>
          <string_parameter name="executionMode" value="immediate"/>
          <string_parameter name="applyWhere" value="at locations matching CEL"/>
          <string_parameter name="applyWhen" value="during op resolve"/>
          <string_parameter name="modifierNameMode" value="node name"/>
          <string_parameter name="modifierName" value="modifier"/>
          <string_parameter name="resolveIds" value=""/>
          <number_parameter name="recursiveEnable" value="0"/>
          <string_parameter name="disableAt" value=""/>
          <string_parameter name="inputBehavior" value="by index"/>
          <number_parameter name="multisampleUserOpArgs" value="1"/>
          <group_parameter hints="{}" name="user">
            <string_parameter expression="=^/user.annotation" hints="{&apos;help&apos;: &apos;tokens must be surounded by &lt;&gt;&apos;}" name="annotation_template"/>
            <number_parameter expression="=^/user.color.color_gamma" hints="{&apos;slidercenter&apos;: &apos;1.0&apos;, &apos;max&apos;: &apos;5.0&apos;, &apos;slidermax&apos;: &apos;4.0&apos;, &apos;slider&apos;: &apos;True&apos;}" isexpression="true" name="annotation_color_gamma"/>
            <number_parameter expression="=^/user.color.annotations_colored" hints="{&apos;widget&apos;: &apos;boolean&apos;}" isexpression="true" name="annotation_colored"/>
            <number_parameter expression="=^/user.color.lights_colored" hints="{&apos;widget&apos;: &apos;boolean&apos;}" isexpression="true" name="lights_colored"/>
          </group_parameter>
        </group_parameter>
      </node>
      <node baseType="Dot" name="Dot48" ns_viewState="2" type="Dot" x="-0.0" y="-2864.0">
        <port name="input" source="LightViewerAnnotate.i0" type="in"/>
        <port name="output" type="out"/>
        <group_parameter name="Dot48"/>
      </node>
      <node baseType="Dot" name="Dot84" ns_viewState="2" type="Dot" x="-0.0" y="-3168">
        <port name="input" source="OpS_lva_0001.out" type="in"/>
        <port name="output" returns="o0" type="out"/>
        <group_parameter name="Dot84"/>
      </node>
    </node>
  </node>
</katana>

<katana release="4.5v1" version="4.5.1.000008">
  <node name="__SAVE_exportedNodes" type="Group">
    <node baseType="Group" edited="true" eyepointx="10.6631" eyepointy="-3006.67" eyepointz="0.0" name="LightViewerAnnotate" ns_basicDisplay="1.0" ns_errorGlow="0.0" ns_fromContext="legacy" ns_iconName="" ns_viewState="2.0" selected="true" type="Group" viewscalex="1.0" viewscaley="1.0" viewscalez="1.0" x="-320.0" y="144.0">
      <port name="i0" type="in"/>
      <port name="o0" type="out"/>
      <group_parameter name="LightViewerAnnotate">
        <group_parameter hints="{&apos;hideTitle&apos;: &apos;True&apos;}" name="user">
          <string_parameter hints="{&apos;help&apos;: &apos;&lt;p&gt;this is build using tokens(ex: &amp;lt;token&amp;gt;)&lt;/p&gt;\n&lt;p&gt;\ntokens available depends of the script configuration. &lt;br&gt; Available tokens for Arnold are:\n&lt;/p&gt;\n&lt;i&gt;\naov, name, color, samples, exposure, intensity\n&lt;/i&gt;&apos;}" name="annotation" value="&lt;name&gt;_&lt;exposure&gt;"/>
          <string_parameter hints="{&apos;widget&apos;: &apos;cel&apos;, &apos;help&apos;: &apos;&lt;p&gt;Make sure the locations matched by CEL are &lt;b&gt;only&lt;/b&gt; lights.&lt;/p&gt;&apos;}" name="CEL" value="((/root/world/lgt//*{@type == &quot;light&quot;}))"/>
          <group_parameter name="color">
            <number_parameter hints="{&apos;widget&apos;: &apos;boolean&apos;}" name="annotations_colored" value="0"/>
            <number_parameter hints="{&apos;widget&apos;: &apos;boolean&apos;}" name="lights_colored" value="0"/>
            <number_parameter hints="{&apos;slidercenter&apos;: &apos;1.0&apos;, &apos;max&apos;: &apos;4.0&apos;, &apos;slidermax&apos;: &apos;4.0&apos;, &apos;slider&apos;: &apos;True&apos;}" name="color_gamma" value="1"/>
          </group_parameter>
          <group_parameter name="about">
            <string_parameter name="author_" value="Liam Collod"/>
            <string_parameter name="info_" value="Annotate (&amp; color) lights in the viewer using their attributes.&#0010;"/>
            <number_parameter name="version_" value="2"/>
          </group_parameter>
        </group_parameter>
      </group_parameter>
      <node baseType="OpScript" name="OpS_lgva0001" ns_errorGlow="0.0" ns_viewState="2.0" type="OpScript" x="2e-06" y="-3008.0">
        <port name="i0" source="In_lgva0001.output" type="in"/>
        <port name="out" type="out"/>
        <group_parameter name="OpS_lgva0001">
          <string_parameter expression="=^/user.CEL" name="CEL"/>
          <string_parameter name="location" value="/root/world/location"/>
          <group_parameter name="script">
            <string_parameter name="lua" value="--[[&#0010;version=16&#0010;author=Liam Collod&#0010;last_modified=12/03/2022&#0010;&#0010;Annotate (&amp; color) lights in the viewer using their attributes.&#0010;&#0010;OpScript for Foundry&apos;s Katana software&#0010;&#0010;[OpScript setup]&#0010;  parameters:&#0010;    location:  /root/world/lgt//*{@type==&quot;light&quot;}&#0010;    applyWhere: at locations matching CEL&#0010;  user(type)(default_value):&#0010;    user.annotation_color_gamma(float)(2): gamma controler for the color if lights and annotations&#0010;    user.annotation_colored(bool)(true): true to colro the annotation in the viewer&#0010;    user.lights_colored(bool)(true): true to color the light in the viewer&#0010;    user.annotation_template(str)(&quot;&lt;name&gt;&quot;): Use tokens to build the annotation for each light.&#0010;       tokens are defined in Light.tokens and are surrounded with &lt;&gt;&#0010;&#0010;[License]&#0010;Copyright 2022 Liam Collod&#0010;&#0010;Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);&#0010;you may not use this file except in compliance with the License.&#0010;You may obtain a copy of the License at&#0010;&#0010;   http://www.apache.org/licenses/LICENSE-2.0&#0010;&#0010;Unless required by applicable law or agreed to in writing, software&#0010;distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&#0010;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#0010;See the License for the specific language governing permissions and&#0010;limitations under the License.&#0010;&#0010;]]&#0010;&#0010;&#0010;--[[ __________________________________________________________________________&#0010;  LUA UTILITIES&#0010;]]&#0010;&#0010;local split&#0010;local round&#0010;local table2string&#0010;local stringify&#0010;local err&#0010;local color_gamma&#0010;local get_user_attr&#0010;&#0010;err = function (...)&#0010;  --[[&#0010;  Raise an error.&#0010;  Concat the given arguments to string and pass them as the error&apos;s message.&#0010;  ]]&#0010;&#0010;  local buf = {&quot;[LgVA][&quot;}&#0010;  buf[ #buf + 1 ] = Interface.GetInputLocationPath()&#0010;  buf[ #buf + 1 ] = &quot;]&quot;&#0010;&#0010;  for i=1, select(&quot;#&quot;,...) do&#0010;    buf[ #buf + 1 ] = tostring(select(i,...))&#0010;  end&#0010;&#0010;  error(table.concat(buf))&#0010;&#0010;end&#0010;&#0010;&#0010;split = function(str, sep)&#0010;  --[[&#0010;  Source: https://stackoverflow.com/a/25449599/13806195&#0010;  ]]&#0010;  local result = {}&#0010;  local regex = (&quot;([^%s]+)&quot;):format(sep)&#0010;  for each in str:gmatch(regex) do&#0010;     table.insert(result, each)&#0010;  end&#0010;  return result&#0010;end&#0010;&#0010;&#0010;round = function(num, numDecimalPlaces)&#0010;  -- Source: http://lua-users.org/wiki/SimpleRound&#0010;  -- Returns: number&#0010;  return tonumber(string.format(&quot;%.&quot; .. (numDecimalPlaces or 0) .. &quot;f&quot;, num))&#0010;end&#0010;&#0010;&#0010;table2string = function(tablevalue)&#0010;    --[[&#0010;  Convert a table to a one line string.&#0010;  If the key is a number, only the value is kept.&#0010;  If the key is something else, it is formatted to &quot;tostring(key)=tostring(value),&quot;&#0010;&#0010;  Parameters:&#0010;    tablevalue(table): table to convert to string&#0010;&#0010;  Returns:&#0010;    str:&#0010;  ]]&#0010;&#0010;  local outtable = {&quot;{&quot;}&#0010;  local ctable = {} -- to avoid string concatenation in loop&#0010;&#0010;  for k, v in pairs(tablevalue) do&#0010;    -- to avoid string concatenation in loop&#0010;    if (type(k) == &quot;number&quot;) then&#0010;      table.insert(outtable, stringify(v)..&quot;, &quot;)&#0010;    else&#0010;      ctable[1] = stringify(k)&#0010;      ctable[2] = &quot;=&quot;&#0010;      ctable[3] = stringify(v)&#0010;      ctable[4] = &quot;, &quot;&#0010;      table.insert(outtable,tostring(table.concat(ctable)))&#0010;    end&#0010;  end&#0010;&#0010;  table.insert(outtable, &quot;}&quot;)&#0010;&#0010;  return table.concat(outtable)&#0010;&#0010;end&#0010;&#0010;&#0010;stringify = function(source)&#0010;  --[[&#0010;  Convert the source to a readable string , based on it&apos;s type.&#0010;  All numbers are rounded to 3 decimals.&#0010;  ]]&#0010;  if not source then&#0010;    return &quot;&quot;&#0010;  end&#0010;&#0010;  local number_round = 3  -- number of decimals to keep.&#0010;&#0010;  if (type(source) == &quot;table&quot;) then&#0010;    if #source == 1 then&#0010;      return stringify(source[1])&#0010;    end&#0010;    source = table2string(source)&#0010;&#0010;  elseif (type(source) == &quot;number&quot;) then&#0010;    source = tostring(round(source, number_round))&#0010;&#0010;  else&#0010;    source = tostring(source)&#0010;&#0010;  end&#0010;&#0010;  return source&#0010;&#0010;end&#0010;&#0010;&#0010;color_gamma =  function(color, gamma)&#0010;  --[[&#0010;  Change the gamma of the given color value (float3)&#0010;&#0010;  Args:&#0010;    color(table): table of float&#0010;    gamma(float): gamma value to apply&#0010;  ]]&#0010;  local out = color&#0010;  for index, color_channel in pairs(color) do&#0010;    out[index] = color_channel ^ gamma&#0010;  end&#0010;  return out&#0010;&#0010;end&#0010;&#0010;&#0010;get_user_attr = function(name, default_value)&#0010;    --[[&#0010;    Return an OpScipt user attribute.&#0010;    If not found return the default_value.&#0010;    ! The user attribute must not be an array of value else only the first item&#0010;    is returned.&#0010;&#0010;    Args:&#0010;        name(str): attribute location (don&apos;t need the &lt;user.&gt;&#0010;        default_value(any): value to return if user attr not found&#0010;    Returns:&#0010;        type depends of input&#0010;    ]]&#0010;    local argvalue = Interface.GetOpArg(&quot;user.&quot;..name)&#0010;    if argvalue then&#0010;        return argvalue:getValue()&#0010;    else&#0010;      return default_value&#0010;    end&#0010;&#0010;end&#0010;&#0010;&#0010;&#0010;--[[ __________________________________________________________________________&#0010;  API&#0010;]]&#0010;&#0010;local function get_light_renderer()&#0010;  --[[&#0010;  From the currently visited light location, return which render-engine it&#0010;   was build for.&#0010;&#0010;  Raise an error if the renderer can&apos;t be found.&#0010;&#0010;  Returns:&#0010;    str: ai, dl, prman&#0010;  ]]&#0010;&#0010;  local mat = Interface.GetAttr(&quot;material&quot;)&#0010;  -- the shader name should always be the first Group index 0&#0010;  if string.find(mat:getChildName(0), &quot;arnold&quot;) then&#0010;    return &quot;ai&quot;&#0010;  elseif string.find(mat:getChildName(0), &quot;dl&quot;) then&#0010;    return &quot;dl&quot;&#0010;  elseif string.find(mat:getChildName(0), &quot;prman&quot;) then&#0010;    return &quot;prman&quot;&#0010;  else&#0010;    err(&quot;[get_light_renderer] Can&apos;t find a render engine for this light !&quot;)&#0010;  end&#0010;&#0010;end&#0010;&#0010;-- scene graph location of the current light visited&#0010;local LOCATION = Interface.GetInputLocationPath()&#0010;local RENDERER = get_light_renderer()&#0010;&#0010;&#0010;local function get_light_attr(attrs_list, default_value)&#0010;--[[&#0010;  Args:&#0010;      attrs_list(table of str):&#0010;        numerical table of attributes path.&#0010;        Function return at the first attribute to return a value.&#0010;      default_value(any):&#0010;        value to return if all attributes return nothing, pass &lt;error&gt; to raise&#0010;        an error instead.&#0010;&#0010;  Returns:&#0010;      type depends of input&#0010;  ]]&#0010;&#0010;  for i=1, #attrs_list do&#0010;&#0010;    local attr = Interface.GetAttr(attrs_list[i])&#0010;    if attr then&#0010;      return attr:getNearestSample(0)&#0010;    end&#0010;&#0010;  end&#0010;&#0010;  if default_value==error then&#0010;    err(&#0010;      &quot;[get_light_attr] No attribute found from&quot;,&#0010;      stringify(attrs_list)&#0010;    )&#0010;  else&#0010;    return default_value&#0010;  end&#0010;&#0010;end&#0010;&#0010;&#0010;local function get_light_name()&#0010;  --[[&#0010;  Returns:&#0010;    str: name of the light based on its scene graph location.&#0010;  ]]&#0010;  local name = split(LOCATION, &quot;/&quot;)&#0010;  return name[#name]  -- return the last element of the list&#0010;end&#0010;&#0010;--[[&#0010;Light table object&#0010;&#0010;the &lt;tokens&gt; key hold all the supported tokens.&#0010;- Each token key hold render-engine keys&#0010;  - each render-engine key hold a table with a &lt;func&gt; and a &lt;params&gt; key.&#0010;&#0010;the default value for &lt;get_light_attr&gt; &lt;params&gt; is returned if the attribute&#0010;is not set locally (not modified)&#0010;]]&#0010;local Light = {&#0010;&#0010;  [&quot;tokens&quot;] = {&#0010;&#0010;    [&quot;name&quot;] = {&#0010;      [&quot;ai&quot;] = { func = get_light_name},&#0010;      [&quot;dl&quot;] = { func = get_light_name},&#0010;      [&quot;prman&quot;] = { func = get_light_name}&#0010;    },&#0010;&#0010;    [&quot;aov&quot;] = {&#0010;      [&quot;ai&quot;] = {&#0010;        func = get_light_attr,&#0010;        params = { { &quot;material.arnoldLightParams.aov&quot; }, &quot;default&quot;},&#0010;      },&#0010;      [&quot;dl&quot;] = {},&#0010;      [&quot;prman&quot;] = {&#0010;        func = get_light_attr,&#0010;        params = { { &quot;material.prmanLightParams.lightGroup&quot; }, &quot;none&quot;},&#0010;      },&#0010;    },&#0010;&#0010;    [&quot;color&quot;] = {&#0010;      [&quot;ai&quot;] = {&#0010;        func = get_light_attr,&#0010;        params = { { &quot;material.arnoldLightParams.color&quot; }, {1,1,1}},&#0010;      },&#0010;      [&quot;dl&quot;] = {&#0010;        func = get_light_attr,&#0010;        params = { { &quot;material.dlLightParams.color&quot; }, {1,1,1}},&#0010;      },&#0010;      [&quot;prman&quot;] = {&#0010;        func = get_light_attr,&#0010;        params = { { &quot;material.prmanLightParams.lightColor&quot; }, {1,1,1}},&#0010;      },&#0010;    },&#0010;&#0010;    [&quot;samples&quot;] = {&#0010;      [&quot;ai&quot;] = {&#0010;        func = get_light_attr,&#0010;        params = { { &quot;material.arnoldLightParams.samples&quot; }, 1},&#0010;      },&#0010;      [&quot;dl&quot;] = {},&#0010;      [&quot;prman&quot;] = {&#0010;        func = get_light_attr,&#0010;        params = { { &quot;material.prmanLightParams.fixedSampleCount&quot; }, 0},&#0010;      },&#0010;    },&#0010;&#0010;    [&quot;exposure&quot;] = {&#0010;      [&quot;ai&quot;] = {&#0010;        func = get_light_attr,&#0010;        params = { { &quot;material.arnoldLightParams.exposure&quot; }, 0},&#0010;      },&#0010;      [&quot;dl&quot;] = {&#0010;        func = get_light_attr,&#0010;        params = { { &quot;material.dlLightParams.exposure&quot; }, 0},&#0010;      },&#0010;      [&quot;prman&quot;] =  {&#0010;        func = get_light_attr,&#0010;        params = { { &quot;material.prmanLightParams.exposure&quot; }, 0},&#0010;      },&#0010;    },&#0010;&#0010;    [&quot;intensity&quot;] = {&#0010;      [&quot;ai&quot;] = {&#0010;        func = get_light_attr,&#0010;        params = { { &quot;material.arnoldLightParams.intensity&quot; }, 1},&#0010;      },&#0010;      [&quot;dl&quot;] = {&#0010;        func = get_light_attr,&#0010;        params = { { &quot;material.dlLightParams.intensity&quot; }, 1},&#0010;      },&#0010;      [&quot;prman&quot;] = {&#0010;        func = get_light_attr,&#0010;        params = { { &quot;material.arnoldLightParams.intensity&quot; }, 1},&#0010;      },&#0010;    }&#0010;&#0010;  }&#0010;&#0010;}&#0010;&#0010;function Light:get(attr_name)&#0010;  --[[&#0010;  Return the light attribute value for the given attribute name&#0010;&#0010;  Returns:&#0010;    type depends of what&apos;s queried, can be nil&#0010;  ]]&#0010;  local attr = self.tokens[attr_name] or {}&#0010;  attr = attr[RENDERER] or {}  -- return the data for the current render-engine&#0010;&#0010;  local func = attr.func&#0010;  local params = attr.params&#0010;  if func then&#0010;    if params then&#0010;      return func(unpack(attr.params))&#0010;    else&#0010;      return func()&#0010;    end&#0010;  else&#0010;    return nil&#0010;  end&#0010;end&#0010;&#0010;function Light:to_annotation(annotation)&#0010;  --[[&#0010;  Args:&#0010;    annotation(str): annotation template submitted by the user (with tokens)&#0010;  Returns:&#0010;    str: annotation with the tokens replaced&#0010;  ]]&#0010;  for attr_name, _ in pairs(self.tokens) do&#0010;    local token = (&quot;&lt;%s&gt;&quot;):format(attr_name)&#0010;    local value = stringify(self:get(attr_name))&#0010;    annotation = string.gsub(annotation, token, value)&#0010;  end&#0010;&#0010;  return annotation&#0010;&#0010;end&#0010;&#0010;&#0010;&#0010;local function run()&#0010;&#0010;  local u_annotation_template = get_user_attr(&quot;annotation_template&quot;, &quot;&lt;name&gt;&quot;)&#0010;  local u_annotation_color_gamma = get_user_attr(&quot;annotation_color_gamma&quot;, 1)&#0010;  local u_annotation_colored = get_user_attr(&quot;annotation_colored&quot;, 1)&#0010;  local u_lights_colored = get_user_attr(&quot;lights_colored&quot;, 1)&#0010;&#0010;  -- 1. Process the annotation&#0010;  local annotation = Light:to_annotation(u_annotation_template)&#0010;  Interface.SetAttr(&#0010;      &quot;viewer.default.annotation.text&quot;,&#0010;      StringAttribute(annotation)&#0010;  )&#0010;&#0010;  -- 2. Process the color&#0010;  local color = Light:get(&quot;color&quot;) -- table of float or nil&#0010;  color = color_gamma(color, u_annotation_color_gamma) or color&#0010;&#0010;  if u_annotation_colored == 1 then&#0010;    Interface.SetAttr(&#0010;        &quot;viewer.default.annotation.color&quot;,&#0010;        FloatAttribute(color or {0.1, 0.1, 0.1})&#0010;    )&#0010;  end&#0010;&#0010;  if u_lights_colored == 1 then&#0010;    Interface.SetAttr(&#0010;        &quot;viewer.default.drawOptions.color&quot;,&#0010;        FloatAttribute(color or {0.1, 1.0, 1.0})&#0010;    )&#0010;  end&#0010;&#0010;  --print(&quot;[LightViewerAnnotate][run] Finished. Annotation set to &lt;&quot;..annotation..&quot;&gt;&quot;)&#0010;&#0010;end&#0010;&#0010;-- execute&#0010;run()"/>
          </group_parameter>
          <string_parameter name="executionMode" value="immediate"/>
          <string_parameter name="applyWhere" value="at locations matching CEL"/>
          <string_parameter name="applyWhen" value="during op resolve"/>
          <string_parameter name="modifierNameMode" value="node name"/>
          <string_parameter name="modifierName" value="modifier"/>
          <string_parameter name="resolveIds" value=""/>
          <number_parameter name="recursiveEnable" value="0"/>
          <string_parameter name="disableAt" value=""/>
          <string_parameter name="inputBehavior" value="by index"/>
          <number_parameter name="multisampleUserOpArgs" value="1"/>
          <group_parameter hints="{}" name="user">
            <string_parameter expression="=^/user.annotation" hints="{&apos;help&apos;: &apos;tokens must be surounded by &lt;&gt;&apos;}" name="annotation_template"/>
            <number_parameter expression="=^/user.color.color_gamma" hints="{&apos;slidercenter&apos;: &apos;1.0&apos;, &apos;max&apos;: &apos;5.0&apos;, &apos;slidermax&apos;: &apos;4.0&apos;, &apos;slider&apos;: &apos;True&apos;}" isexpression="true" name="annotation_color_gamma"/>
            <number_parameter expression="=^/user.color.annotations_colored" hints="{&apos;widget&apos;: &apos;boolean&apos;}" isexpression="true" name="annotation_colored"/>
            <number_parameter expression="=^/user.color.lights_colored" hints="{&apos;widget&apos;: &apos;boolean&apos;}" isexpression="true" name="lights_colored"/>
          </group_parameter>
        </group_parameter>
      </node>
      <node baseType="Dot" name="In_lgva0001" ns_basicDisplay="1" ns_colorb="0.01" ns_colorg="0.01" ns_colorr="0.01" ns_viewState="2.0" type="Dot" x="-0.0" y="-2864.0">
        <port name="input" source="LightViewerAnnotate.i0" type="in"/>
        <port name="output" type="out"/>
        <group_parameter name="In_lgva0001"/>
      </node>
      <node baseType="Dot" name="Out_lgva0001" ns_basicDisplay="1" ns_colorb="0.01" ns_colorg="0.01" ns_colorr="0.01" ns_viewState="2.0" type="Dot" x="-0.0" y="-3168.0">
        <port name="input" source="OpS_lgva0001.out" type="in"/>
        <port name="output" returns="o0" type="out"/>
        <group_parameter name="Out_lgva0001"/>
      </node>
    </node>
  </node>
</katana>
